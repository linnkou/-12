<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>برنامج الهندسة - من إعداد الأستاذ العربي بودهير عبد اللطيف</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;700&family=Tajawal:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
  <style>
    /* تصميم متجاوب مع جميع الشاشات */
    body {
      font-family: 'Roboto Slab', 'Tajawal', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #e1f5fe, #ffffff);
      color: #333;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    .header {
      background: linear-gradient(135deg, #1976d2, #1565c0);
      color: #fff;
      text-align: center;
      padding: 16px 10px;
      font-size: 20px;
      font-weight: 700;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      position: relative;
    }
    .header p {
      font-size: 12px;
      margin-top: 4px;
      color: #e3f2fd;
    }
    /* أزرار تغيير اللغة في الهيدر */
    .lang-switcher {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
    }
    .lang-btn {
      background: rgba(255,255,255,0.3);
      border: none;
      padding: 4px 8px;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
    }
    
    .sidebar {
      width: 100%;
      background: #f0f4f8;
      padding: 10px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow-x: auto;
      height: auto;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      flex-wrap: wrap;
      justify-content: center;
    }
    .sidebar h3 {
      font-size: 14px;
      margin: 10px 0 5px;
      color: #1565c0;
      border-bottom: 1px solid #cfd8dc;
      padding-bottom: 3px;
      width: 100%;
      text-align: center;
    }
    .tool-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .tool-list li {
      padding: 6px 8px;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
      border-radius: 4px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 2px;
    }
    .tool-list li:hover {
      background: #e3f2fd;
      transform: scale(1.05);
      color: #0d47a1;
    }
    .tool-list li i {
      width: 18px;
      text-align: center;
      animation: iconBounce 1.5s infinite;
      font-size: 14px;
    }
    @keyframes iconBounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }
    .tool-category {
      width: 100%;
      margin-bottom: 10px;
    }
    
    .main-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }
    
    .canvas-container {
      border: 2px solid #1976d2;
      border-radius: 8px;
      position: relative;
      background: #fff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      width: 100%;
      max-width: 800px;
      margin: 10px auto;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      border-radius: 8px;
      width: 100%;
      height: 100%;
    }
    
    .tools {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      width: 100%;
      max-width: 800px;
      margin: 10px auto 0 auto;
      padding: 10px;
      background: #fafafa;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      justify-content: center;
    }
    .tool-btn {
      background: #e3f2fd;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: #1565c0;
      transition: background 0.3s, transform 0.2s;
    }
    .tool-btn:hover {
      background: #bbdefb;
      transform: scale(1.05);
    }
    .tool-btn.active {
      background: #1565c0;
      color: #fff;
    }
    .tool-btn i {
      font-size: 16px;
    }
    
    .modal {
      display: none;
      position: fixed;
      z-index: 1100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background: rgba(0, 0, 0, 0.4);
    }
    .modal-content {
      background: #fff;
      margin: 15% auto;
      padding: 15px;
      border: 1px solid #ddd;
      width: 80%;
      max-width: 400px;
      border-radius: 8px;
    }
    .modal-content h4 {
      margin-top: 0;
      text-align: center;
      color: #1565c0;
      font-size: 16px;
    }
    .modal-content label {
      display: block;
      margin-top: 8px;
      font-size: 12px;
    }
    .modal-content input[type="color"],
    .modal-content input[type="number"],
    .modal-content input[type="text"],
    .modal-content select,
    .modal-content input[type="checkbox"] {
      width: 100%;
      padding: 6px;
      margin-top: 4px;
      border: 1px solid #cfd8dc;
      border-radius: 4px;
      font-size: 12px;
    }
    .modal-buttons {
      margin-top: 15px;
      text-align: center;
    }
    .modal-buttons button {
      padding: 6px 12px;
      margin: 0 4px;
      border: none;
      background: #1565c0;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
      font-size: 12px;
    }
    .modal-buttons button:hover {
      background: #0d47a1;
    }
    
    @media (max-width: 600px) {
      .canvas-container {
        width: calc(100% - 20px);
        height: 60vh;
      }
      canvas {
        height: 100%;
      }
    }
    
    @media (min-width: 768px) {
      body {
        flex-direction: row;
      }
      .sidebar {
        width: 200px;
        height: 100vh;
        display: block;
        flex-wrap: nowrap;
        justify-content: flex-start;
        overflow-x: hidden;
      }
      .tool-list {
        flex-direction: column;
        align-items: stretch;
      }
      .tool-list li {
        margin: 0;
        text-align: center;
      }
      .tool-category h3 {
        text-align: right;
      }
    }
  </style>
</head>
<body>
  <!-- الشريط الجانبي -->
  <div class="sidebar">
    <!-- فئة الأدوات الأساسية -->
    <div class="tool-category">
      <h3 id="basicToolsCategoryTitle" data-key="basicTools">أدوات أساسية</h3>
      <ul class="tool-list">
        <li onclick="activateTool('move')"><i class="fas fa-hand-paper"></i> <span data-key="moveTool">تحريك الورقة</span></li>
        <li onclick="activateTool('select')"><i class="fas fa-mouse-pointer"></i> <span data-key="selectTool">تحديد عنصر</span></li>
        <li onclick="pointToolClicked()"><i class="fas fa-dot-circle"></i> <span data-key="pointTool">نقطة</span></li>
        <li onclick="activateTool('link')"><i class="fas fa-link"></i> <span data-key="linkTool">ربط نقاط</span></li>
        <li onclick="activateTool('phrases')"><i class="fas fa-pencil-alt"></i> <span data-key="phrasesTool">كتابة جمل/حروف</span></li>
        <li onclick="activateTool('angle')"><i class="fas fa-ruler-combined"></i> <span data-key="angleTool">زاوية</span></li>
        <li onclick="activateTool('delete')"><i class="fas fa-trash"></i> <span data-key="deleteTool">مسح</span></li>
        <li id="centerTool" onclick="centerCanvas()"><i class="fas fa-expand-arrows-alt"></i> <span data-key="centerTool">توسيط الشاشة</span></li>
      </ul>
    </div>
    <!-- قسم المستقيمات -->
    <div class="tool-category">
      <h3 data-key="linesCategory">المستقيمات</h3>
      <ul class="tool-list">
        <li onclick="openLineModal('line')"><i class="fas fa-ruler"></i> <span data-key="line">مستقيم</span></li>
        <li onclick="openLineModal('segment')"><i class="fas fa-ruler-horizontal"></i> <span data-key="segment">قطعة مستقيمة</span></li>
        <li onclick="activateTool('ray')"><i class="fas fa-long-arrow-alt-right"></i> <span data-key="ray">شعاع</span></li>
      </ul>
    </div>
    <!-- قسم الأشكال والمضلعات -->
    <div class="tool-category">
      <h3 id="shapesCategoryTitle" data-key="shapesCategory">أشكال ومضلعات</h3>
      <ul class="tool-list">
        <li onclick="openShapeModal('rectangle')">
          <i class="fas fa-border-style"></i> 
          <span data-key="rectangle">مستطيل</span>
        </li>
        <li onclick="openShapeModal('square')">
          <i class="fas fa-th-large"></i> 
          <span data-key="square">مربع</span>
        </li>
        <li onclick="openShapeModal('triangle')">
          <i class="fas fa-play"></i> 
          <span data-key="triangle">مثلث</span>
        </li>
        <li onclick="openShapeModal('rhombus')">
          <i class="fas fa-diamond"></i> 
          <span data-key="rhombus">معين</span>
        </li>
        <li onclick="activateTool('polyFree')">
          <i class="fas fa-draw-polygon"></i> 
          <span data-key="polyFree">مضلع كيفي</span>
        </li>
        <li onclick="openPolyRegularModal()">
          <i class="fas fa-shapes"></i> 
          <span data-key="polyRegular">مضلع منتظم</span>
        </li>
        <li onclick="openCircleModal()">
          <i class="fas fa-circle"></i> 
          <span data-key="circle">دائرة</span>
        </li>
      </ul>
    </div>
    <!-- قسم الأدوات الإضافية -->
    <div class="tool-category">
      <h3 id="additionalToolsTitle" data-key="additionalTools">أدوات إضافية</h3>
      <ul class="tool-list">
        <li onclick="toggleTeacher()">
          <i class="fas fa-chalkboard"></i> 
          <span data-key="axes">المحاور</span>
        </li>
        <li onclick="toggleGrid()">
          <i class="fas fa-th"></i> 
          <span data-key="grid">التقسيمات</span>
        </li>
        <li onclick="toggleTeacherNumbers()">
          <i class="fas fa-sort-numeric-up"></i> 
          <span data-key="axesNumbers">أرقام المحاور</span>
        </li>
        <li onclick="undoAction()">
          <i class="fas fa-undo"></i> 
          <span data-key="undo">تراجع</span>
        </li>
        <li onclick="redoAction()">
          <i class="fas fa-redo"></i> 
          <span data-key="redo">إعادة</span>
        </li>
        <li onclick="activateTool('save')">
          <i class="fas fa-save"></i> 
          <span data-key="save">حفظ</span>
        </li>
        <li onclick="activateTool('bucket')">
          <i class="fas fa-fill-drip"></i> 
          <span data-key="bucket">تعبئة</span>
        </li>
      </ul>
    </div>
  </div>

  <!-- المحتوى الرئيسي -->
  <div class="main-content">
    <div class="header">
      <div class="lang-switcher">
        <button class="lang-btn" onclick="changeLanguage('ar')">عربي</button>
        <button class="lang-btn" onclick="changeLanguage('en')">EN</button>
        <button class="lang-btn" onclick="changeLanguage('fr')">FR</button>
      </div>
      <div id="headerTitle" data-key="headerTitle">برنامج الهندسة</div>
      <p id="headerSubtitle" data-key="headerSubtitle">من إعداد الأستاذ العربي بودهير عبد اللطيف</p>
    </div>
    <!-- لوحة الرسم -->
    <div class="canvas-container">
      <canvas id="drawingCanvas" width="800" height="600"></canvas>
    </div>
    <!-- شريط الإختصارات -->
    <div class="tools">
      <div class="tool-btn" id="pointTool" onclick="pointToolClicked()">
        <i class="fas fa-dot-circle"></i>
        <span data-key="pointTool">نقطة</span>
      </div>
      <div class="tool-btn" id="lineTool" onclick="openLineModal('line')">
        <i class="fas fa-ruler"></i>
        <span data-key="line">مستقيم</span>
      </div>
      <div class="tool-btn" id="circleTool" onclick="activateTool('circle')">
        <i class="far fa-circle"></i>
        <span data-key="circle">دائرة</span>
      </div>
      <div class="tool-btn" id="penTool" onclick="activateTool('pen')">
        <i class="fas fa-pen"></i>
        <span>قلم حر</span>
      </div>
      <div class="tool-btn" id="moveTool" onclick="activateTool('move')">
        <i class="fas fa-hand-paper"></i>
        <span data-key="moveTool">تحريك الورقة</span>
      </div>
      <div class="tool-btn" id="selectTool" onclick="activateTool('select')">
        <i class="fas fa-mouse-pointer"></i>
        <span data-key="selectTool">تحديد عنصر</span>
      </div>
      <div class="tool-btn" id="uploadImageBtn" onclick="document.getElementById('uploadInput').click()">
        <i class="fas fa-upload"></i>
        <span data-key="uploadImage">رفع صورة</span>
      </div>
      <div class="tool-btn" id="copyDrawingBtn" onclick="copySelectedObjects()">
        <i class="fas fa-clone"></i>
        <span data-key="copyDrawing">نسخ الرسومات</span>
      </div>
      <div class="tool-btn" id="centerToolShort" onclick="centerCanvas()">
        <i class="fas fa-expand-arrows-alt"></i>
        <span data-key="centerTool">توسيط الشاشة</span>
      </div>
      <div class="tool-btn" id="fillTool" onclick="activateTool('bucket')">
        <i class="fas fa-fill-drip"></i>
        <span data-key="bucket">تعبئة</span>
      </div>
    </div>
  </div>

  <!-- عنصر رفع الصورة المخفي -->
  <input type="file" id="uploadInput" style="display:none" accept="image/*" onchange="handleImageUpload(event)" />

  <!-- النوافذ المنبثقة -->

  <!-- نافذة إعدادات الشكل -->
  <div id="shapeModal" class="modal">
    <div class="modal-content">
      <h4 id="shapeModalTitle" data-key="shapeSettings">إعدادات الشكل</h4>
      <div id="dimensionFields">
        <!-- يتم تعبئة الحقول ديناميكيًا حسب الشكل -->
      </div>
      <label for="emptyShapeCheckbox" data-key="emptyShape">شكل فارغ بدون تعبئة:</label>
      <input type="checkbox" id="emptyShapeCheckbox" />
      <label for="strokeColorShapeInput" data-key="strokeColor">لون الحدود:</label>
      <input type="color" id="strokeColorShapeInput" value="#ff5722" />
      <label for="fillColorShapeInput" data-key="fillColor">لون التعبئة:</label>
      <input type="color" id="fillColorShapeInput" value="#ffffff" />
      <div class="modal-buttons">
        <button onclick="confirmShapeModal()" data-key="confirm">تأكيد</button>
        <button onclick="closeShapeModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة إعدادات الخط -->
  <div id="lineModal" class="modal">
    <div class="modal-content">
      <h4 id="lineModalTitle" data-key="lineSettings">إعدادات الخط</h4>
      <label for="lineStyleSelect" data-key="lineStyle">نمط الخط:</label>
      <select id="lineStyleSelect">
        <option value="solid" data-key="solid">غير متقطعة</option>
        <option value="dashed" data-key="dashed">متقطعة</option>
      </select>
      <label for="lineLengthInput" data-key="lineLength">الطول (للقطعة - بالسنتيمتر):</label>
      <input type="number" id="lineLengthInput" value="10" min="1" />
      <label for="lineColorInput" data-key="lineColor">لون الخط:</label>
      <input type="color" id="lineColorInput" value="#007bff" />
      <label for="lineThicknessInput" data-key="lineThickness">سماكة الخط:</label>
      <input type="number" id="lineThicknessInput" value="2" min="1" />
      <div class="modal-buttons">
        <button onclick="confirmLineModal()" data-key="confirm">تأكيد</button>
        <button onclick="closeLineModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة تحرير النصوص -->
  <div id="textEditModal" class="modal">
    <div class="modal-content">
      <h4 data-key="textSettings">إعدادات النص</h4>
      <label for="userTextInput" data-key="textLabel">النص:</label>
      <input type="text" id="userTextInput" placeholder="اكتب هنا" />
      <label for="fontFamilySelect" data-key="fontFamily">نوع الخط:</label>
      <select id="fontFamilySelect">
        <option value="Tajawal">Tajawal</option>
        <option value="Arial">Arial</option>
        <option value="Tahoma">Tahoma</option>
      </select>
      <label for="fontSizeInput" data-key="fontSize">حجم الخط:</label>
      <input type="number" id="fontSizeInput" value="20" min="10" />
      <label for="textColorInput" data-key="textColor">لون النص:</label>
      <input type="color" id="textColorInput" value="#333333" />
      <div class="modal-buttons">
        <button onclick="confirmTextEditModal()" data-key="confirm">تأكيد</button>
        <button onclick="closeTextEditModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة إعدادات قياس الزاوية -->
  <div id="angleModal" class="modal">
    <div class="modal-content">
      <h4 data-key="angleSettings">إعدادات قياس الزاوية</h4>
      <label for="showAngleCheckbox">
        <input type="checkbox" id="showAngleCheckbox" checked /> <span data-key="showAngle">إظهار القياس</span>
      </label>
      <label for="angleDirectionSelect" data-key="angleDirection">اتجاه التشفير:</label>
      <select id="angleDirectionSelect">
        <option value="normal" data-key="normal">طبيعي</option>
        <option value="reversed" data-key="reversed">مقلوب</option>
      </select>
      <label for="desiredAngleInput" data-key="desiredAngle">قيمة الزاوية (بالدرجات):</label>
      <input type="number" id="desiredAngleInput" value="45" min="1" max="179" />
      <div class="modal-buttons">
        <button onclick="confirmAngleModal()" data-key="confirm">تأكيد</button>
        <button onclick="closeAngleModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة إعدادات المضلع المنتظم -->
  <div id="polyModal" class="modal">
    <div class="modal-content">
      <h4 data-key="polyRegularSettings">إعدادات المضلع المنتظم</h4>
      <label for="sidesInput" data-key="sides">عدد الأضلاع:</label>
      <input type="number" id="sidesInput" value="5" min="3" />
      <label for="radiusInput" data-key="radius">القطر المطلوب (بـ cm):</label>
      <input type="number" id="radiusInput" value="50" min="10" />
      <label for="strokeColorPolyInput" data-key="strokeColor">لون الحدود:</label>
      <input type="color" id="strokeColorPolyInput" value="#ff00ff" />
      <div class="modal-buttons">
        <button onclick="confirmPolyModal()" data-key="confirm">تأكيد</button>
        <button onclick="closePolyModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة إعدادات النقطة -->
  <div id="pointModal" class="modal">
    <div class="modal-content">
      <h4 data-key="pointSettings">إعدادات النقطة</h4>
      <label for="pointTypeSelect" data-key="pointType">نوع النقطة:</label>
      <select id="pointTypeSelect">
        <option value="circle" data-key="circlePoint">دائري</option>
        <option value="x" data-key="xPoint">X</option>
      </select>
      <label for="pointSizeInput" data-key="pointSize">الحجم (بـ cm):</label>
      <input type="number" id="pointSizeInput" value="0.3" min="0.1" step="0.1" />
      <label for="pointColorInput" data-key="pointColor">لون النقطة:</label>
      <input type="color" id="pointColorInput" value="#007bff" />
      <div class="modal-buttons">
        <button onclick="confirmPointModal()" data-key="confirm">تأكيد</button>
        <button onclick="closePointModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة إعدادات الحفظ -->
  <div id="saveModal" class="modal">
    <div class="modal-content">
      <h4 data-key="saveSettings">إعدادات الحفظ</h4>
      <label for="saveWidthInput" data-key="saveWidth">عرض الورقة (بـ cm):</label>
      <input type="number" id="saveWidthInput" value="21" min="5" />
      <label for="saveHeightInput" data-key="saveHeight">ارتفاع الورقة (بـ cm):</label>
      <input type="number" id="saveHeightInput" value="29.7" min="5" />
      <div class="modal-buttons">
        <button onclick="confirmSaveModal()" data-key="confirm">حفظ</button>
        <button onclick="closeSaveModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة إعدادات الدائرة -->
  <div id="circleShapeModal" class="modal">
    <div class="modal-content">
      <h4 data-key="circleSettings">إعدادات الدائرة</h4>
      <label for="circleRadiusInput" data-key="circleRadius">نصف القطر (بـ cm):</label>
      <input type="number" id="circleRadiusInput" value="5" min="1" />
      <label for="strokeColorCircleInput" data-key="strokeColor">لون الحدود:</label>
      <input type="color" id="strokeColorCircleInput" value="#007bff" />
      <label for="fillColorCircleInput" data-key="fillColor">لون التعبئة:</label>
      <input type="color" id="fillColorCircleInput" value="#ffffff" />
      <label for="circleFillTypeSelect" data-key="fillType">نوع التعبئة:</label>
      <select id="circleFillTypeSelect">
        <option value="filled" data-key="filled">ممتلئة</option>
        <option value="empty" data-key="empty">فارغة</option>
      </select>
      <label for="circleShapeSelect" data-key="circleShape">شكل الدائرة:</label>
      <select id="circleShapeSelect">
        <option value="normal">عادية</option>
        <option value="half">نصف دائرة</option>
        <option value="quarter">ربع دائرة</option>
      </select>
      <div class="modal-buttons">
        <button onclick="confirmCircleModal()" data-key="confirm">تأكيد</button>
        <button onclick="closeCircleModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>
  
  <!-- نافذة تعديل خصائص الرسم -->
  <div id="propertyModal" class="modal">
    <div class="modal-content">
      <h4 data-key="propertySettings">تعديل الخصائص</h4>
      <label for="propStrokeColorInput" data-key="strokeColor">لون الحدود:</label>
      <input type="color" id="propStrokeColorInput" value="#000000" />
      <label for="propStrokeWidthInput" data-key="strokeWidth">سماكة الحدود:</label>
      <input type="number" id="propStrokeWidthInput" value="2" min="1" />
      <div id="fillColorContainer" style="display: none;">
        <label for="propFillColorInput" data-key="fillColor">لون التعبئة:</label>
        <input type="color" id="propFillColorInput" value="#ffffff" />
      </div>
      <div class="modal-buttons">
        <button onclick="updateObjectProperties()" data-key="confirm">تحديث</button>
        <button onclick="closePropertyModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>

  <!-- نافذة تعبئة الشكل (دلو) -->
  <div id="fillModal" class="modal">
    <div class="modal-content">
      <h4 data-key="fillModalTitle">تعبئة الشكل</h4>
      <label for="fillColorInput" data-key="chooseFillColor">اختر لون التعبئة:</label>
      <input type="color" id="fillColorInput" value="#00ff00" />
      <div class="modal-buttons">
        <button onclick="confirmFillModal()" data-key="confirm">تأكيد</button>
        <button onclick="closeFillModal()" data-key="cancel">إلغاء</button>
      </div>
    </div>
  </div>

  <script>
    /**************** إعدادات Undo/Redo ****************/
    let undoStack = [];
    let redoStack = [];
    let restoreInProgress = false;
    const CM_IN_PX = 37.8; // بكسل لكل سنتيمتر

    // متغير لدعم الزوم بإصبعين
    let lastTouchDistance = null;

    let gridGroup = null;
    let polyFreePoints = [];

    // إعدادات النقطة بعد تأكيدها
    let pointSettings = null;
    
    // تعريف متغير لتخزين العنصر الذي سيتم تعبئته بواسطة الدلو
    let currentFillObject = null;

    // إنشاء الكانفاس
    const canvas = new fabric.Canvas("drawingCanvas", {
      renderOnAddRemove: true,
      selection: true,
    });
    canvas.uniScaleTransform = true;

    let activeTool = null;

    /* --- دوال Undo/Redo --- */
    function saveState() {
      if (!restoreInProgress) {
        undoStack.push(JSON.stringify(canvas));
        redoStack = [];
      }
    }
    function undoAction() {
      if (undoStack.length > 1) {
        restoreInProgress = true;
        redoStack.push(JSON.stringify(canvas));
        undoStack.pop();
        canvas.loadFromJSON(undoStack[undoStack.length - 1], function () {
          canvas.renderAll();
          restoreInProgress = false;
        });
      }
    }
    function redoAction() {
      if (redoStack.length > 0) {
        restoreInProgress = true;
        undoStack.push(JSON.stringify(canvas));
        const redoState = redoStack.pop();
        canvas.loadFromJSON(redoState, function () {
          canvas.renderAll();
          restoreInProgress = false;
        });
      }
    }
    canvas.on("object:added", saveState);
    canvas.on("object:modified", saveState);
    canvas.on("object:removed", saveState);

    /* --- إنشاء النقاط --- */
    function createCirclePoint(left, top, size, color) {
      const point = new fabric.Circle({
        radius: size,
        fill: color,
        left: left,
        top: top,
        selectable: true,
        originX: "center",
        originY: "center",
      });
      point.isPoint = true;
      return point;
    }
    function createXPoint(left, top, size, color) {
      const offset = size;
      const line1 = new fabric.Line([left - offset, top - offset, left + offset, top + offset], {
        stroke: color,
        strokeWidth: 2,
        selectable: false,
      });
      const line2 = new fabric.Line([left - offset, top + offset, left + offset, top - offset], {
        stroke: color,
        strokeWidth: 2,
        selectable: false,
      });
      const group = new fabric.Group([line1, line2], {
        left: left,
        top: top,
        originX: "center",
        originY: "center",
        selectable: true
      });
      group.isPoint = true;
      return group;
    }
    function addNewPointWithSettings(left, top, type, size, color) {
      let point = type === "circle" ? createCirclePoint(left, top, size, color) : createXPoint(left, top, size, color);
      canvas.add(point);
      canvas.requestRenderAll();
      return point;
    }

    /* --- الربط بين النقاط --- */
    let linkPoints = [];
    function onCanvasLinkMouseDown(e) {
      if (e.target && e.target.isPoint) {
        if (!linkPoints.includes(e.target)) {
          linkPoints.push(e.target);
          e.target.set({ stroke: "red", strokeWidth: 2 });
          canvas.requestRenderAll();
        }
        if (linkPoints.length === 2) {
          const pt1 = linkPoints[0];
          const pt2 = linkPoints[1];
          const line = new fabric.Line([pt1.left, pt1.top, pt2.left, pt2.top], {
            stroke: "#007bff",
            strokeWidth: 2,
            selectable: true,
          });
          line.dynamicLink = true;
          line.linkFrom = pt1;
          line.linkTo = pt2;
          canvas.add(line);
          pt1.set({ stroke: null, strokeWidth: 0 });
          pt2.set({ stroke: null, strokeWidth: 0 });
          linkPoints = [];
          canvas.requestRenderAll();
        }
      }
    }
    canvas.on("object:moving", function(e) {
      if (e.target && e.target.isPoint) {
        updateDynamicLinks(e.target);
      }
    });
    function updateDynamicLinks(movedPoint) {
      canvas.getObjects().forEach((obj) => {
        if (obj.dynamicLink && (obj.linkFrom === movedPoint || obj.linkTo === movedPoint)) {
          obj.set({
            x1: obj.linkFrom.left,
            y1: obj.linkFrom.top,
            x2: obj.linkTo.left,
            y2: obj.linkTo.top,
          });
          obj.setCoords();
          canvas.requestRenderAll();
        }
      });
    }

    /* --- نافذة تحرير النصوص --- */
    function openTextEditModal() {
      document.getElementById("textEditModal").style.display = "block";
    }
    function closeTextEditModal() {
      document.getElementById("textEditModal").style.display = "none";
    }
    function confirmTextEditModal() {
      const userText = document.getElementById("userTextInput").value;
      const fontFamily = document.getElementById("fontFamilySelect").value;
      const fontSize = parseFloat(document.getElementById("fontSizeInput").value) || 20;
      const textColor = document.getElementById("textColorInput").value;
      if (userText) {
        const textObj = new fabric.IText(userText, {
          left: canvas.getWidth() / 2,
          top: canvas.getHeight() / 2,
          fontFamily: fontFamily,
          fontSize: fontSize,
          fill: textColor,
          selectable: true,
        });
        canvas.add(textObj);
        canvas.requestRenderAll();
      }
      document.getElementById("userTextInput").value = "";
      closeTextEditModal();
      activeTool = null;
    }

    /* --- إعدادات النقطة --- */
    function openPointModal() {
      document.getElementById("pointModal").style.display = "block";
    }
    function closePointModal() {
      document.getElementById("pointModal").style.display = "none";
    }
    function pointToolClicked() {
      activeTool = "point";
      openPointModal();
    }
    function confirmPointModal() {
      const type = document.getElementById("pointTypeSelect").value;
      const cmSize = parseFloat(document.getElementById("pointSizeInput").value) || 0.3;
      const sizePx = cmSize * CM_IN_PX;
      const color = document.getElementById("pointColorInput").value;
      pointSettings = { type: type, size: sizePx, color: color };
      closePointModal();
    }

    /* --- دوال رسم الأشكال --- */
    let currentShape = null;
    function openShapeModal(shape) {
      currentShape = shape;
      document.getElementById("shapeModalTitle").innerText = translations[currentLanguage].shapeSettings + " " + shape;
      let fieldsHTML = "";
      if (shape === "rectangle") {
        fieldsHTML += `<label for="rectWidthInput" data-key="rectWidth">${translations[currentLanguage].rectWidth} (بـ cm):</label>
        <input type="number" id="rectWidthInput" value="10" min="1" />
        <label for="rectHeightInput" data-key="rectHeight">${translations[currentLanguage].rectHeight} (بـ cm):</label>
        <input type="number" id="rectHeightInput" value="8" min="1" />`;
      } else if (shape === "square") {
        fieldsHTML += `<label for="squareSizeInput" data-key="squareSize">${translations[currentLanguage].squareSize} (بـ cm):</label>
        <input type="number" id="squareSizeInput" value="10" min="1" />`;
      } else if (shape === "triangle") {
        fieldsHTML += `<label for="triBaseInput" data-key="triBase">${translations[currentLanguage].triBase}</label>
        <input type="number" id="triBaseInput" value="10" min="1" />
        <label for="triSide2Input" data-key="triSide2">${translations[currentLanguage].triSide2}</label>
        <input type="number" id="triSide2Input" value="8" min="1" />
        <label for="triSide3Input" data-key="triSide3">${translations[currentLanguage].triSide3}</label>
        <input type="number" id="triSide3Input" value="8" min="1" />`;
      } else if (shape === "rhombus") {
        fieldsHTML += `<label for="rhombusOffsetInput" data-key="rhombusOffset">${translations[currentLanguage].rhombusOffset}</label>
        <input type="number" id="rhombusOffsetInput" value="5" min="1" />`;
      }
      document.getElementById("dimensionFields").innerHTML = fieldsHTML;
      document.getElementById("emptyShapeCheckbox").checked = false;
      document.getElementById("shapeModal").style.display = "block";
    }
    function closeShapeModal() {
      document.getElementById("shapeModal").style.display = "none";
    }
    function confirmShapeModal() {
      const stroke = document.getElementById("strokeColorShapeInput").value;
      let fill = document.getElementById("fillColorShapeInput").value;
      if(document.getElementById("emptyShapeCheckbox").checked) {
        fill = "transparent";
      }
      if (currentShape === "rectangle") {
        const widthCm = parseFloat(document.getElementById("rectWidthInput").value) || 10;
        const heightCm = parseFloat(document.getElementById("rectHeightInput").value) || 8;
        drawRectangle(widthCm * CM_IN_PX, heightCm * CM_IN_PX, stroke, fill);
      } else if (currentShape === "square") {
        const sizeCm = parseFloat(document.getElementById("squareSizeInput").value) || 10;
        drawSquare(sizeCm * CM_IN_PX, stroke, fill);
      } else if (currentShape === "triangle") {
        const baseCm = parseFloat(document.getElementById("triBaseInput").value);
        const side2Cm = parseFloat(document.getElementById("triSide2Input").value);
        const side3Cm = parseFloat(document.getElementById("triSide3Input").value);
        drawTriangle(baseCm * CM_IN_PX, side2Cm * CM_IN_PX, side3Cm * CM_IN_PX, stroke);
      } else if (currentShape === "rhombus") {
        const offsetCm = parseFloat(document.getElementById("rhombusOffsetInput").value) || 5;
        drawRhombus(offsetCm * CM_IN_PX, stroke, fill);
      }
      closeShapeModal();
    }

    function drawRectangle(width, height, stroke, fill) {
      const rect = new fabric.Rect({
        left: canvas.getWidth() / 2 - width / 2,
        top: canvas.getHeight() / 2 - height / 2,
        fill: fill,
        stroke: stroke,
        strokeWidth: 2,
        width: width,
        height: height,
        selectable: true,
      });
      canvas.add(rect);
    }
    function drawSquare(size, stroke, fill) {
      const square = new fabric.Rect({
        left: canvas.getWidth() / 2 - size / 2,
        top: canvas.getHeight() / 2 - size / 2,
        fill: fill,
        stroke: stroke,
        strokeWidth: 2,
        width: size,
        height: size,
        selectable: true,
      });
      canvas.add(square);
    }
    function drawTriangle(a, b, c, stroke) {
      if (a + b <= c || a + c <= b || b + c <= a) {
        alert("الأطوال المدخلة لا تُشكل مثلثاً صحيحاً.");
        return;
      }
      const centerX = canvas.getWidth() / 2;
      const centerY = canvas.getHeight() / 2;
      const pt1 = { x: centerX - a / 2, y: centerY + 50 };
      const pt2 = { x: centerX + a / 2, y: centerY + 50 };
      const D = (a * a + c * c - b * b) / (2 * a);
      const h = Math.sqrt(c * c - D * D);
      const pt3 = { x: pt1.x + D, y: pt1.y - h };
      const triangle = new fabric.Polygon([pt1, pt2, pt3], {
        fill: "transparent",
        stroke: stroke,
        strokeWidth: 2,
        selectable: true,
      });
      canvas.add(triangle);
    }

    function drawRhombus(offset, stroke, fill) {
      const centerX = canvas.getWidth() / 2;
      const centerY = canvas.getHeight() / 2;
      const points = [
        { x: centerX, y: centerY - offset },
        { x: centerX + offset, y: centerY },
        { x: centerX, y: centerY + offset },
        { x: centerX - offset, y: centerY }
      ];
      const rhombus = new fabric.Polygon(points, {
        fill: fill,
        stroke: stroke,
        strokeWidth: 2,
        selectable: true,
        originX: "center",
        originY: "center",
      });
      canvas.add(rhombus);
    }

    /* --- دوال إعدادات الخط --- */
    let currentLineTool = null;
    function openLineModal(tool) {
      currentLineTool = tool;
      document.getElementById("lineModalTitle").innerText = translations[currentLanguage].lineSettings + " (" + (tool === "line" ? translations[currentLanguage].line : translations[currentLanguage].segment) + ")";
      document.getElementById("lineModal").style.display = "block";
    }
    function closeLineModal() {
      document.getElementById("lineModal").style.display = "none";
    }
    function confirmLineModal() {
      const style = document.getElementById("lineStyleSelect").value;
      const lineColor = document.getElementById("lineColorInput").value;
      const lineThickness = parseInt(document.getElementById("lineThicknessInput").value) || 2;
      if (currentLineTool === "line") {
        drawLine(style, lineColor, lineThickness);
      } else if (currentLineTool === "segment") {
        const lengthCm = parseFloat(document.getElementById("lineLengthInput").value) || 10;
        drawSegment(style, lengthCm, lineColor, lineThickness);
      }
      closeLineModal();
    }
    function drawLine(style, color, thickness) {
      let dash = style === "dashed" ? [10, 5] : null;
      const line = new fabric.Line(
        [canvas.getWidth() * 0.1, canvas.getHeight() / 2, canvas.getWidth() * 0.9, canvas.getHeight() / 2],
        {
          stroke: color,
          strokeWidth: thickness,
          selectable: true,
          strokeDashArray: dash
        }
      );
      canvas.add(line);
    }
    function drawSegment(style, lengthCm, color, thickness) {
      let dash = style === "dashed" ? [10, 5] : null;
      const lengthPx = lengthCm * CM_IN_PX;
      const centerX = canvas.getWidth() / 2;
      const centerY = canvas.getHeight() / 2;
      const half = lengthPx / 2;
      const seg = new fabric.Line([centerX - half, centerY, centerX + half, centerY], {
        stroke: color,
        strokeWidth: thickness,
        selectable: true,
        strokeDashArray: dash
      });
      const pt1 = createCirclePoint(centerX - half, centerY, 5, color);
      const pt2 = createCirclePoint(centerX + half, centerY, 5, color);
      const segmentGroup = new fabric.Group([seg, pt1, pt2], { selectable: true });
      canvas.add(segmentGroup);
    }

    /* --- باقي الدوال --- */
    function drawCircle() {
      // سيتم استدعاء نافذة إعدادات الدائرة عند الاستخدام.
    }
    function drawRay() {
      const startX = canvas.getWidth() / 2;
      const startY = canvas.getHeight() / 2;
      const endX = startX + 100;
      const endY = startY - 50;
      const ray = new fabric.Line([startX, startY, endX, endY], {
        stroke: "#6f42c1",
        strokeWidth: 2,
        selectable: true,
      });
      const angle = Math.atan2(endY - startY, endX - startX);
      const arrow = new fabric.Triangle({
        left: endX,
        top: endY,
        originX: "center",
        originY: "center",
        width: 12,
        height: 18,
        angle: angle * (180 / Math.PI) + 90,
        fill: "#6f42c1",
        selectable: true,
      });
      const rayGroup = new fabric.Group([ray, arrow], { selectable: true });
      canvas.add(rayGroup);
    }

    /* --- دوال إعداد المضلع الحر --- */
    function onCanvasPolyFreeMouseDown(e) {
      const pointer = canvas.getPointer(e.e);
      if (polyFreePoints.length > 0) {
        const firstPoint = polyFreePoints[0];
        const dx = pointer.x - firstPoint.x,
          dy = pointer.y - firstPoint.y;
        if (Math.sqrt(dx * dx + dy * dy) < 10 && polyFreePoints.length >= 3) {
          const poly = new fabric.Polygon(polyFreePoints, {
            fill: "transparent",
            stroke: "#ff00ff",
            strokeWidth: 2,
            selectable: true,
          });
          canvas.add(poly);
          polyFreePoints = [];
          canvas.off("mouse:down", onCanvasPolyFreeMouseDown);
          canvas.off("mouse:dblclick", onCanvasPolyFreeDblClick);
          activeTool = null;
          return;
        }
      }
      polyFreePoints.push({ x: pointer.x, y: pointer.y });
      addNewPointWithSettings(pointer.x, pointer.y, "circle", 5, "#007bff");
    }
    function onCanvasPolyFreeDblClick(e) {
      if (polyFreePoints.length >= 3) {
        const poly = new fabric.Polygon(polyFreePoints, {
          fill: "transparent",
          stroke: "#ff00ff",
          strokeWidth: 2,
          selectable: true,
        });
        canvas.add(poly);
      }
      polyFreePoints = [];
      canvas.off("mouse:down", onCanvasPolyFreeMouseDown);
      canvas.off("mouse:dblclick", onCanvasPolyFreeDblClick);
      activeTool = null;
    }

    /* --- إعداد المضلع المنتظم --- */
    function openPolyRegularModal() {
      document.getElementById("polyModal").style.display = "block";
    }
    function closePolyModal() {
      document.getElementById("polyModal").style.display = "none";
    }
    function confirmPolyModal() {
      const sides = parseInt(document.getElementById("sidesInput").value) || 5;
      const radiusCm = parseFloat(document.getElementById("radiusInput").value) || 50;
      const radiusPx = radiusCm * CM_IN_PX;
      const stroke = document.getElementById("strokeColorPolyInput").value;
      drawPolyRegular(sides, radiusPx, stroke);
      closePolyModal();
    }
    function drawPolyRegular(sides, radius, stroke) {
      const center = { x: canvas.getWidth()/2, y: canvas.getHeight()/2 };
      let points = [];
      for (let i = 0; i < sides; i++) {
        let angle = (2 * Math.PI * i) / sides;
        points.push({
          x: center.x + radius * Math.cos(angle),
          y: center.y + radius * Math.sin(angle)
        });
      }
      const poly = new fabric.Polygon(points, {
        fill: "transparent",
        stroke: stroke,
        strokeWidth: 2,
        selectable: true,
      });
      canvas.add(poly);
      canvas.off("mouse:down", onCanvasPolyRegularMouseDown);
      activeTool = null;
    }
    function onCanvasPolyRegularMouseDown(e) {
      // يتم استخدام النافذة المنبثقة لهذا المثال.
    }

    /* --- عرض المحاور "المحاور" --- */
    let teacherGroup = null;
    function addTeacher() {
      if (teacherGroup) return;
      const w = canvas.getWidth();
      const h = canvas.getHeight();
      const centerX = w / 2;
      const centerY = h / 2;
      const horizontal = new fabric.Line([0, centerY, w, centerY], {
        stroke: "#000",
        strokeWidth: 1,
        selectable: false
      });
      const vertical = new fabric.Line([centerX, 0, centerX, h], {
        stroke: "#000",
        strokeWidth: 1,
        selectable: false
      });
      teacherGroup = new fabric.Group([horizontal, vertical], { selectable: false });
      teacherGroup.nonEditable = true;
      canvas.add(teacherGroup);
      canvas.requestRenderAll();
    }
    function removeTeacher() {
      if (teacherGroup) {
        canvas.remove(teacherGroup);
        teacherGroup = null;
      }
    }
    function toggleTeacher() {
      if (teacherGroup) removeTeacher();
      else addTeacher();
    }

    /* --- أرقام المحاور --- */
    let teacherNumbersGroup = null;
    function addTeacherNumbers() {
      if (teacherNumbersGroup) return;
      let texts = [];
      const spacing = CM_IN_PX;
      const centerX = canvas.getWidth() / 2;
      const centerY = canvas.getHeight() / 2;
      const maxX = canvas.getWidth();
      const maxY = canvas.getHeight();
      for (let x = 0; x <= maxX; x += spacing) {
        const num = Math.round((x - centerX) / CM_IN_PX);
        let text = new fabric.Text(num.toString(), {
          left: x,
          top: centerY + 5,
          fontSize: 10,
          fill: "#999",
          selectable: false,
        });
        texts.push(text);
      }
      for (let y = 0; y <= maxY; y += spacing) {
        const num = Math.round((centerY - y) / CM_IN_PX);
        let text = new fabric.Text(num.toString(), {
          left: centerX + 5,
          top: y,
          fontSize: 10,
          fill: "#999",
          selectable: false,
        });
        texts.push(text);
      }
      teacherNumbersGroup = new fabric.Group(texts, { selectable: false });
      teacherNumbersGroup.nonEditable = true;
      canvas.add(teacherNumbersGroup);
      canvas.requestRenderAll();
    }
    function removeTeacherNumbers() {
      if (teacherNumbersGroup) {
        canvas.remove(teacherNumbersGroup);
        teacherNumbersGroup = null;
      }
    }
    function toggleTeacherNumbers() {
      if (!teacherNumbersGroup) addTeacherNumbers();
      else removeTeacherNumbers();
    }

    /* --- التقسيمات (الشبكة) --- */
    let gridVisible = false;
    function toggleGrid() {
      if (!gridVisible) {
        const spacing = CM_IN_PX;
        const w = canvas.getWidth();
        const h = canvas.getHeight();
        let lines = [];
        for (let i = 0; i <= w / spacing; i++) {
          let x = i * spacing;
          let vertical = new fabric.Line([x, 0, x, h], {
            stroke: "#eee",
            selectable: false,
          });
          lines.push(vertical);
        }
        for (let i = 0; i <= h / spacing; i++) {
          let y = i * spacing;
          let horizontal = new fabric.Line([0, y, w, y], {
            stroke: "#eee",
            selectable: false,
          });
          lines.push(horizontal);
        }
        gridGroup = new fabric.Group(lines, { selectable: false });
        canvas.add(gridGroup);
        gridVisible = true;
      } else {
        canvas.remove(gridGroup);
        gridGroup = null;
        gridVisible = false;
      }
    }

    /* --- حفظ العمل --- */
    function openSaveModal() {
      document.getElementById("saveModal").style.display = "block";
    }
    function closeSaveModal() {
      document.getElementById("saveModal").style.display = "none";
    }
    function confirmSaveModal() {
      let widthCm = parseInt(document.getElementById("saveWidthInput").value) || (canvas.getWidth() / CM_IN_PX);
      let heightCm = parseInt(document.getElementById("saveHeightInput").value) || (canvas.getHeight() / CM_IN_PX);
      let widthPx = widthCm * CM_IN_PX;
      let heightPx = heightCm * CM_IN_PX;
      let multiplier = Math.min(widthPx / canvas.getWidth(), heightPx / canvas.getHeight());
      const prevBg = canvas.backgroundColor;
      canvas.backgroundColor = "#ffffff";
      canvas.renderAll();
      const dataURL = canvas.toDataURL({ multiplier: multiplier });
      canvas.backgroundColor = prevBg;
      canvas.renderAll();
      const link = document.createElement("a");
      link.download = "work.png";
      link.href = dataURL;
      link.click();
      closeSaveModal();
    }
    function saveCanvas() {
      openSaveModal();
    }
    function zoomIn() {
      let zoom = canvas.getZoom();
      canvas.setZoom(zoom * 1.1);
      canvas.requestRenderAll();
    }
    function zoomOut() {
      let zoom = canvas.getZoom();
      canvas.setZoom(zoom / 1.1);
      canvas.requestRenderAll();
    }
    canvas.on("mouse:wheel", function(opt) {
      let delta = opt.e.deltaY;
      let zoom = canvas.getZoom();
      zoom *= 0.999 ** delta;
      if (zoom > 20) zoom = 20;
      if (zoom < 0.01) zoom = 0.01;
      canvas.setZoom(zoom);
      opt.e.preventDefault();
      opt.e.stopPropagation();
    });

    /* --- دعم التكبير والتصغير بإصبعين --- */
    function getTouchDistance(touches){
      const touch1 = touches[0];
      const touch2 = touches[1];
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    canvas.upperCanvasEl.addEventListener("touchstart", function(e) {
      if (e.touches.length === 1 && activeTool === "move") {
        e.preventDefault();
        startPan(e);
      } else if (e.touches.length === 2) {
        e.preventDefault();
        lastTouchDistance = getTouchDistance(e.touches);
      }
    }, { passive: false });

    canvas.upperCanvasEl.addEventListener("touchmove", function(e) {
      if (e.touches.length === 1 && activeTool === "move" && isPanning) {
        e.preventDefault();
        panMove(e);
      } else if (e.touches.length === 2) {
        e.preventDefault();
        const currentDistance = getTouchDistance(e.touches);
        if (lastTouchDistance !== null) {
          const zoomFactor = currentDistance / lastTouchDistance;
          const zoom = canvas.getZoom() * zoomFactor;
          canvas.setZoom(zoom);
          canvas.requestRenderAll();
        }
        lastTouchDistance = currentDistance;
      }
    }, { passive: false });

    canvas.upperCanvasEl.addEventListener("touchend", function(e) {
      if (e.touches.length < 2) {
        lastTouchDistance = null;
      }
      if (e.touches.length === 0 && isPanning) {
        endPan(e);
      }
      if (!isPanning && activeTool === "point" && pointSettings) {
        const pointer = canvas.getPointer(e);
        addNewPointWithSettings(pointer.x, pointer.y, pointSettings.type, pointSettings.size, pointSettings.color);
      }
    }, { passive: false });

    /* --- تحريك اللوحة (Pan) --- */
    let isPanning = false;
    let lastPosX, lastPosY;
    function startPan(e) {
      isPanning = true;
      let evt = e.e || e;
      lastPosX = evt.clientX || evt.touches[0].clientX;
      lastPosY = evt.clientY || evt.touches[0].clientY;
      canvas.discardActiveObject();
    }
    function panMove(e) {
      if (!isPanning) return;
      let evt = e.e || e;
      let currentX = evt.clientX || evt.touches[0].clientX;
      let currentY = evt.clientY || evt.touches[0].clientY;
      let deltaX = currentX - lastPosX;
      let deltaY = currentY - lastPosY;
      lastPosX = currentX;
      lastPosY = currentY;
      canvas.relativePan({ x: deltaX, y: deltaY });
    }
    function endPan(e) {
      isPanning = false;
    }

    canvas.off("mouse:down");
    canvas.on("mouse:down", function(e) {
      if (activeTool === "move") {
        startPan(e);
        return;
      }
      
      if (activeTool === "bucket") {
        e.preventDefault();
        let obj = e.target;
        if (obj && (obj.type === "rect" || obj.type === "circle" || obj.type === "polygon")) {
          currentFillObject = obj;
          openFillModal();
        } else {
          alert("الرجاء اختيار شكل مغلق للتعبئة.");
        }
        activeTool = null;
        return;
      }
      
      if (activeTool !== "move" && activeTool !== "point" && !isPanning && e.target && !e.target.nonEditable) {
        if(activeTool !== "select"){
          openPropertyModal(e.target, e.pointer.x, e.pointer.y);
        }
      }
      if(activeTool === "point" && pointSettings){
        const pointer = canvas.getPointer(e.e);
        addNewPointWithSettings(pointer.x, pointer.y, pointSettings.type, pointSettings.size, pointSettings.color);
      }
    });

    canvas.on("mouse:move", function(e) {
      if (isPanning) { panMove(e); }
    });

    canvas.on("mouse:up", function(e) {
      if (isPanning) { endPan(e); }
    });

    /* --- إعدادات قياس الزاوية --- */
    let anglePoints = [];
    function handleAngleClick(e) {
      const pointer = canvas.getPointer(e.e);
      const pt = addNewPointWithSettings(pointer.x, pointer.y, "circle", 5, "#007bff");
      anglePoints.push(pt);
      if (anglePoints.length === 2) {
        canvas.off("mouse:down", handleAngleClick);
        openAngleModal();
      }
    }
    function openAngleModal() {
      document.getElementById("angleModal").style.display = "block";
    }
    function closeAngleModal() {
      document.getElementById("angleModal").style.display = "none";
      anglePoints = [];
    }
    function confirmAngleModal() {
      const showMeasurement = document.getElementById("showAngleCheckbox").checked;
      const direction = document.getElementById("angleDirectionSelect").value;
      let desiredAngleDeg = parseFloat(document.getElementById("desiredAngleInput").value) || 45;
      if (direction === "reversed") desiredAngleDeg = -desiredAngleDeg;
      if(anglePoints.length !== 2) return;
      const vertex = anglePoints[0];
      const firstEnd = anglePoints[1];
      const initialAngle = Math.atan2(firstEnd.top - vertex.top, firstEnd.left - vertex.left);
      const secondAngle = initialAngle + (desiredAngleDeg * Math.PI / 180);
      const length = Math.sqrt((firstEnd.left - vertex.left)**2 + (firstEnd.top - vertex.top)**2);
      const secondEnd = {
        x: vertex.left + length * Math.cos(secondAngle),
        y: vertex.top + length * Math.sin(secondAngle)
      };
      const ray1 = new fabric.Line([vertex.left, vertex.top, firstEnd.left, firstEnd.top], {
        stroke: "#007bff",
        strokeWidth: 2,
        selectable: true,
      });
      const ray2 = new fabric.Line([vertex.left, vertex.top, secondEnd.x, secondEnd.y], {
        stroke: "#007bff",
        strokeWidth: 2,
        selectable: true,
      });
      canvas.add(ray1);
      canvas.add(ray2);
      if (showMeasurement) {
        const txt = new fabric.Text(Math.abs(desiredAngleDeg) + "°", {
          left: vertex.left + 20,
          top: vertex.top - 20,
          fontSize: 16,
          fill: "#aa00ff",
          selectable: true,
        });
        canvas.add(txt);
      }
      canvas.requestRenderAll();
      anglePoints = [];
      closeAngleModal();
      activeTool = null;
    }

    /* --- إعدادات الدائرة --- */
    function openCircleModal() {
      document.getElementById("circleShapeModal").style.display = "block";
    }
    function closeCircleModal() {
      document.getElementById("circleShapeModal").style.display = "none";
    }
    function confirmCircleModal() {
      const radiusCm = parseFloat(document.getElementById("circleRadiusInput").value) || 5;
      const radiusPx = radiusCm * CM_IN_PX;
      const stroke = document.getElementById("strokeColorCircleInput").value;
      let fill = document.getElementById("fillColorCircleInput").value;
      const fillType = document.getElementById("circleFillTypeSelect").value;
      if(fillType === "empty") {
        fill = "transparent";
      }
      const shapeType = document.getElementById("circleShapeSelect").value;
      drawCircleCustom(radiusPx, stroke, fill, shapeType);
      closeCircleModal();
    }
    function drawCircleCustom(radius, stroke, fill, shapeType) {
      const centerX = canvas.getWidth() / 2;
      const centerY = canvas.getHeight() / 2;
      if (shapeType === "half") {
        const circle = new fabric.Circle({
          left: centerX,
          top: centerY,
          radius: radius,
          stroke: stroke,
          fill: fill,
          strokeWidth: 2,
          originX: "center",
          originY: "center",
        });
        circle.clipPath = new fabric.Rect({
          left: 0,
          top: -radius,
          width: radius * 2,
          height: radius,
          originX: "center",
          originY: "center",
        });
        canvas.add(circle);
      } else if (shapeType === "quarter") {
        const circle = new fabric.Circle({
          left: centerX,
          top: centerY,
          radius: radius,
          stroke: stroke,
          fill: fill,
          strokeWidth: 2,
          originX: "center",
          originY: "center",
        });
        circle.clipPath = new fabric.Rect({
          left: 0,
          top: -radius,
          width: radius,
          height: radius,
          originX: "center",
          originY: "center",
        });
        canvas.add(circle);
      } else {
        const circle = new fabric.Circle({
          left: centerX,
          top: centerY,
          radius: radius,
          stroke: stroke,
          fill: fill,
          strokeWidth: 2,
          originX: "center",
          originY: "center",
        });
        canvas.add(circle);
      }
    }

    /* --- تعديل خصائص الرسم --- */
    let currentPropertyObject = null;
    function openPropertyModal(obj, x, y) {
      currentPropertyObject = obj;
      document.getElementById("propStrokeColorInput").value = obj.stroke || "#000000";
      document.getElementById("propStrokeWidthInput").value = obj.strokeWidth || 1;
      if(obj.fill !== undefined) {
        document.getElementById("fillColorContainer").style.display = "block";
        document.getElementById("propFillColorInput").value = obj.fill || "#ffffff";
      } else {
        document.getElementById("fillColorContainer").style.display = "none";
      }
      let modal = document.getElementById("propertyModal");
      modal.style.display = "block";
      let canvasContainer = document.querySelector(".canvas-container");
      let containerRect = canvasContainer.getBoundingClientRect();
      modal.style.left = (containerRect.left + x + 20) + "px";
      modal.style.top = (containerRect.top + y) + "px";
    }
    function closePropertyModal() {
      document.getElementById("propertyModal").style.display = "none";
      currentPropertyObject = null;
    }
    function updateObjectProperties() {
      if(currentPropertyObject) {
        let strokeColor = document.getElementById("propStrokeColorInput").value;
        let strokeWidth = parseInt(document.getElementById("propStrokeWidthInput").value) || 1;
        currentPropertyObject.set("stroke", strokeColor);
        currentPropertyObject.set("strokeWidth", strokeWidth);
        if(currentPropertyObject.fill !== undefined) {
          let fillColor = document.getElementById("propFillColorInput").value;
          currentPropertyObject.set("fill", fillColor);
        }
        canvas.requestRenderAll();
      }
      closePropertyModal();
    }

    /* --- نافذة تعبئة الشكل (دلو) --- */
    let currentFillObjects = [];
    function openFillModal(obj, x, y) {
      if (!Array.isArray(obj)) {
        currentFillObjects = [obj || currentFillObject];
      } else {
        currentFillObjects = obj;
      }
      document.getElementById("fillColorInput").value = currentFillObjects[0].fill || "#00ff00";
      document.getElementById("fillModal").style.display = "block";
      let canvasContainer = document.querySelector(".canvas-container");
      let containerRect = canvasContainer.getBoundingClientRect();
      document.getElementById("fillModal").style.left = (containerRect.left + (x || 20)) + "px";
      document.getElementById("fillModal").style.top = (containerRect.top + (y || 20)) + "px";
    }
    function closeFillModal() {
      document.getElementById("fillModal").style.display = "none";
      currentFillObjects = [];
    }
    function confirmFillModal() {
      if (currentFillObjects.length > 0) {
        const fillColor = document.getElementById("fillColorInput").value;
        currentFillObjects.forEach(obj => {
          if(obj.fill !== undefined) {
            obj.set("fill", fillColor);
          }
        });
        canvas.requestRenderAll();
      }
      closeFillModal();
      activeTool = null;
    }

    /* --- وظائف رفع الصور ونسخ الرسومات --- */
    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(f) {
        fabric.Image.fromURL(f.target.result, function(img) {
          img.set({
            left: canvas.getWidth() / 2,
            top: canvas.getHeight() / 2,
            originX: "center",
            originY: "center"
          });
          canvas.add(img);
        });
      }
      reader.readAsDataURL(file);
    }
    function copySelectedObjects() {
      let selected = canvas.getActiveObjects();
      if(selected.length > 0) {
        selected.forEach(obj => {
          obj.clone(function(clonedObj) {
            clonedObj.set({
              left: obj.left + 10,
              top: obj.top + 10,
            });
            canvas.add(clonedObj);
            canvas.requestRenderAll();
          });
        });
      }
    }

    /* --- تفعيل الأدوات --- */
    function activateTool(tool) {
      activeTool = tool;
      canvas.off("mouse:down");
      canvas.off("mouse:move");
      canvas.off("mouse:up");
      document.querySelectorAll(".tool-btn").forEach((btn) => btn.classList.remove("active"));
      const toolElement = document.getElementById(
        tool === "move"
          ? "moveTool"
          : (tool === "select" ? "selectTool" : (tool === "bucket" ? "fillTool" : tool + "Tool"))
      );
      if (toolElement) toolElement.classList.add("active");
      canvas.isDrawingMode = (tool === "pen");
      if (tool === "move") {
        canvas.selection = false;
        canvas.defaultCursor = "grab";
        canvas.on("mouse:down", function (e) { startPan(e); });
        canvas.on("mouse:move", function (e) { if (isPanning) { panMove(e); } });
        canvas.on("mouse:up", function (e) { if (isPanning) { endPan(e); } });
      } else if (tool === "select") {
        canvas.selection = true;
        canvas.defaultCursor = "default";
      } else if (tool === "point") {
        canvas.on("mouse:down", function(e) {
          if(pointSettings){
            const pointer = canvas.getPointer(e.e);
            addNewPointWithSettings(pointer.x, pointer.y, pointSettings.type, pointSettings.size, pointSettings.color);
          }
        });
      } else if (tool === "link") {
        linkPoints = [];
        canvas.on("mouse:down", onCanvasLinkMouseDown);
      } else if (tool === "angle") {
        let selectedPoints = canvas.getActiveObjects().filter(obj => obj.isPoint);
        if(selectedPoints.length === 2){
          anglePoints = selectedPoints;
          openAngleModal();
        } else {
          anglePoints = [];
          canvas.on("mouse:down", handleAngleClick);
        }
      } else if (tool === "phrases") {
        openTextEditModal();
      } else if (tool === "delete") {
        deleteSelected();
      } else if (tool === "rectangle" || tool === "square" || tool === "triangle" || tool === "rhombus") {
        openShapeModal(tool);
      } else if (tool === "line") {
        openLineModal("line");
      } else if (tool === "circle") {
        openCircleModal();
      } else if (tool === "segment") {
        openLineModal("segment");
      } else if (tool === "ray") {
        drawRay();
      } else if (tool === "polyFree") {
        polyFreePoints = [];
        canvas.on("mouse:down", onCanvasPolyFreeMouseDown);
        canvas.on("mouse:dblclick", onCanvasPolyFreeDblClick);
      } else if (tool === "polyRegular") {
        openPolyRegularModal();
      } else if (tool === "pen") {
        // إعدادات قلم الحر موجودة ضمن Fabric
      } else if (tool === "save") {
        saveCanvas();
      }
      else if (tool === "bucket") {
        activeTool = "bucket";
        canvas.once("mouse:down", function(e) {
          let obj = e.target;
          if (obj && (obj.type === "rect" || obj.type === "circle" || obj.type === "polygon")) {
            currentFillObject = obj;
            openFillModal();
          } else {
            alert("الرجاء اختيار شكل مغلق للتعبئة.");
          }
          activeTool = null;
        });
      } else {
        console.log("الأداة غير متوفرة حالياً: " + tool);
      }
    }
    function deleteSelected() {
      let actives = canvas.getActiveObjects();
      if (actives.length) {
        actives.forEach(obj => canvas.remove(obj));
        canvas.discardActiveObject();
        canvas.requestRenderAll();
      } else {
        alert("الرجاء اختيار كائن واحد أو أكثر للحذف.");
      }
    }

    /* --- دالة توسيط الشاشة --- */
    function centerCanvas(){
      canvas.viewportTransform[4] = 0;
      canvas.viewportTransform[5] = 0;
      canvas.requestRenderAll();
    }

    /* --- ضبط حجم لوحة الرسم حسب حجم الشاشة --- */
    function resizeCanvas() {
      const container = document.querySelector(".canvas-container");
      if (container) {
        let newWidth, newHeight;
        if(window.innerWidth < 768){
          newWidth = window.innerWidth - 20;
          newHeight = window.innerHeight * 0.6;
        } else {
          newWidth = Math.min(window.innerWidth - 20, 800);
          newHeight = newWidth * 0.75;
        }
        container.style.width = newWidth + "px";
        container.style.height = newHeight + "px";
        canvas.setWidth(container.clientWidth);
        canvas.setHeight(container.clientHeight);
        canvas.calcOffset();
        canvas.requestRenderAll();
      }
    }
    window.addEventListener("resize", resizeCanvas);

    window.onload = () => {
      activateTool("point");
      resizeCanvas();
      const centerTool = document.getElementById("centerTool");
      if(centerTool) {
        centerTool.addEventListener("touchend", function(e) {
          e.preventDefault();
          centerCanvas();
        });
      }
      const centerToolShort = document.getElementById("centerToolShort");
      if(centerToolShort) {
        centerToolShort.addEventListener("touchend", function(e) {
          e.preventDefault();
          centerCanvas();
        });
      }
      changeLanguage('ar');
    };

    /* ===================== ترجمة الواجهة ===================== */
    const translations = {
      ar: {
        headerTitle: "برنامج الهندسة",
        headerSubtitle: "من إعداد الأستاذ العربي بودهير عبد اللطيف",
        basicTools: "أدوات أساسية",
        moveTool: "تحريك الورقة",
        selectTool: "تحديد عنصر",
        pointTool: "نقطة",
        linkTool: "ربط نقاط",
        phrasesTool: "كتابة جمل/حروف",
        angleTool: "زاوية",
        deleteTool: "مسح",
        centerTool: "توسيط الشاشة",
        linesCategory: "المستقيمات",
        line: "مستقيم",
        segment: "قطعة مستقيمة",
        ray: "شعاع",
        shapesCategory: "أشكال ومضلعات",
        rectangle: "مستطيل",
        square: "مربع",
        triangle: "مثلث",
        rhombus: "معين",
        polyFree: "مضلع كيفي",
        polyRegular: "مضلع منتظم",
        circle: "دائرة",
        additionalTools: "أدوات إضافية",
        axes: "المحاور",
        grid: "التقسيمات",
        axesNumbers: "أرقام المحاور",
        undo: "تراجع",
        redo: "إعادة",
        save: "حفظ",
        bucket: "تعبئة",
        uploadImage: "رفع صورة",
        copyDrawing: "نسخ الرسومات",
        shapeSettings: "إعدادات الشكل",
        emptyShape: "شكل فارغ بدون تعبئة",
        strokeColor: "لون الحدود",
        fillColor: "لون التعبئة",
        lineSettings: "إعدادات الخط",
        lineStyle: "نمط الخط",
        lineLength: "الطول (للقطعة - بالسنتيمتر)",
        lineColor: "لون الخط",
        lineThickness: "سماكة الخط",
        textSettings: "إعدادات النص",
        textLabel: "النص",
        fontFamily: "نوع الخط",
        fontSize: "حجم الخط",
        textColor: "لون النص",
        angleSettings: "إعدادات قياس الزاوية",
        showAngle: "إظهار القياس",
        angleDirection: "اتجاه التشفير",
        desiredAngle: "قيمة الزاوية (بالدرجات)",
        polyRegularSettings: "إعدادات المضلع المنتظم",
        sides: "عدد الأضلاع",
        radius: "القطر المطلوب (بـ cm)",
        pointSettings: "إعدادات النقطة",
        pointType: "نوع النقطة",
        pointSize: "الحجم (بـ cm)",
        pointColor: "لون النقطة",
        saveSettings: "إعدادات الحفظ",
        saveWidth: "عرض الورقة (بـ cm)",
        saveHeight: "ارتفاع الورقة (بـ cm)",
        circleSettings: "إعدادات الدائرة",
        circleRadius: "نصف القطر (بـ cm)",
        fillType: "نوع التعبئة",
        circleShape: "شكل الدائرة",
        propertySettings: "تعديل الخصائص",
        strokeWidth: "سماكة الحدود",
        fillModalTitle: "تعبئة الشكل",
        chooseFillColor: "اختر لون التعبئة",
        confirm: "تأكيد",
        cancel: "إلغاء",
        rectWidth: "عرض المستطيل",
        rectHeight: "ارتفاع المستطيل",
        squareSize: "طول ضلع المربع",
        solid: "غير متقطعة",
        dashed: "متقطعة",
        filled: "ممتلئة",
        empty: "فارغة",
        normal: "طبيعي",
        reversed: "مقلوب",
        circlePoint: "دائري",
        xPoint: "X",
        triBase: "طول القاعدة (بـ cm):",
        triSide2: "الضلع الثاني (بـ cm):",
        triSide3: "الضلع الثالث (بـ cm):",
        rhombusOffset: "المسافة من المركز (بـ cm):"
      },
      en: {
        headerTitle: "Geometry Program",
        headerSubtitle: "Prepared by Elarbi Boudihir Abdellatif",
        basicTools: "Basic Tools",
        moveTool: "Move Canvas",
        selectTool: "Select Object",
        pointTool: "Point",
        linkTool: "Link Points",
        phrasesTool: "Write Text",
        angleTool: "Angle",
        deleteTool: "Delete",
        centerTool: "Center Canvas",
        linesCategory: "Lines",
        line: "Line",
        segment: "Segment",
        ray: "Ray",
        shapesCategory: "Shapes & Polygons",
        rectangle: "Rectangle",
        square: "Square",
        triangle: "Triangle",
        rhombus: "Rhombus",
        polyFree: "Free Polygon",
        polyRegular: "Regular Polygon",
        circle: "Circle",
        additionalTools: "Additional Tools",
        axes: "Axes",
        grid: "Grid",
        axesNumbers: "Axes Numbers",
        undo: "Undo",
        redo: "Redo",
        save: "Save",
        bucket: "Bucket Fill",
        uploadImage: "Upload Image",
        copyDrawing: "Copy Drawings",
        shapeSettings: "Shape Settings",
        emptyShape: "Empty Shape (No Fill)",
        strokeColor: "Stroke Color",
        fillColor: "Fill Color",
        lineSettings: "Line Settings",
        lineStyle: "Line Style",
        lineLength: "Length (for segments - in cm)",
        lineColor: "Line Color",
        lineThickness: "Line Thickness",
        textSettings: "Text Settings",
        textLabel: "Text",
        fontFamily: "Font Family",
        fontSize: "Font Size",
        textColor: "Text Color",
        angleSettings: "Angle Settings",
        showAngle: "Show Measurement",
        angleDirection: "Angle Direction",
        desiredAngle: "Angle Value (in degrees)",
        polyRegularSettings: "Regular Polygon Settings",
        sides: "Number of Sides",
        radius: "Desired Diameter (in cm)",
        pointSettings: "Point Settings",
        pointType: "Point Type",
        pointSize: "Size (in cm)",
        pointColor: "Point Color",
        saveSettings: "Save Settings",
        saveWidth: "Paper Width (in cm)",
        saveHeight: "Paper Height (in cm)",
        circleSettings: "Circle Settings",
        circleRadius: "Radius (in cm)",
        fillType: "Fill Type",
        circleShape: "Circle Shape",
        propertySettings: "Edit Properties",
        strokeWidth: "Stroke Width",
        fillModalTitle: "Fill Shape",
        chooseFillColor: "Choose Fill Color",
        confirm: "Confirm",
        cancel: "Cancel",
        rectWidth: "Rectangle Width",
        rectHeight: "Rectangle Height",
        squareSize: "Square Side Length",
        solid: "Solid",
        dashed: "Dashed",
        filled: "Filled",
        empty: "Empty",
        normal: "Normal",
        reversed: "Reversed",
        circlePoint: "Circular",
        xPoint: "X",
        triBase: "Base Length (in cm):",
        triSide2: "Second Side (in cm):",
        triSide3: "Third Side (in cm):",
        rhombusOffset: "Distance from Center (in cm):"
      },
      fr: {
        headerTitle: "Programme de Géométrie",
        headerSubtitle: "Préparé par Elarbi Boudihir Abdellatif",
        basicTools: "Outils de Base",
        moveTool: "Déplacer le Canevas",
        selectTool: "Sélectionner l'Objet",
        pointTool: "Point",
        linkTool: "Relier les Points",
        phrasesTool: "Écrire du Texte",
        angleTool: "Angle",
        deleteTool: "Supprimer",
        centerTool: "Centrer le Canevas",
        linesCategory: "Lignes",
        line: "Ligne",
        segment: "Segment",
        ray: "Rayon",
        shapesCategory: "Formes & Polygones",
        rectangle: "Rectangle",
        square: "Carré",
        triangle: "Triangle",
        rhombus: "Losange",
        polyFree: "Polygone Libre",
        polyRegular: "Polygone Régulier",
        circle: "Cercle",
        additionalTools: "Outils Supplémentaires",
        axes: "Axes",
        grid: "Grille",
        axesNumbers: "Numéros des axes",
        undo: "Annuler",
        redo: "Rétablir",
        save: "Enregistrer",
        bucket: "Remplissage",
        uploadImage: "Télécharger l'image",
        copyDrawing: "Copier les dessins",
        shapeSettings: "Paramètres de la Forme",
        emptyShape: "Forme Vide (Sans Remplissage)",
        strokeColor: "Couleur du Contour",
        fillColor: "Couleur de Remplissage",
        lineSettings: "Paramètres de la Ligne",
        lineStyle: "Style de la Ligne",
        lineLength: "Longueur (pour segments - en cm)",
        lineColor: "Couleur de la Ligne",
        lineThickness: "Épaisseur de la Ligne",
        textSettings: "Paramètres du Texte",
        textLabel: "Texte",
        fontFamily: "Police",
        fontSize: "Taille de la Police",
        textColor: "Couleur du Texte",
        angleSettings: "Paramètres de l'Angle",
        showAngle: "Afficher la Mesure",
        angleDirection: "Direction de l'Angle",
        desiredAngle: "Valeur de l'Angle (en degrés)",
        polyRegularSettings: "Paramètres du Polygone Régulier",
        sides: "Nombre de Côtés",
        radius: "Diamètre désiré (en cm)",
        pointSettings: "Paramètres du Point",
        pointType: "Type de Point",
        pointSize: "Taille (en cm)",
        pointColor: "Couleur du Point",
        saveSettings: "Paramètres d'Enregistrement",
        saveWidth: "Largeur du Papier (en cm)",
        saveHeight: "Hauteur du Papier (en cm)",
        circleSettings: "Paramètres du Cercle",
        circleRadius: "Rayon (en cm)",
        fillType: "Type de Remplissage",
        circleShape: "Forme du Cercle",
        propertySettings: "Modifier les Propriétés",
        strokeWidth: "Épaisseur du Contour",
        fillModalTitle: "Remplissage de Forme",
        chooseFillColor: "Choisissez la Couleur de Remplissage",
        confirm: "Confirmer",
        cancel: "Annuler",
        rectWidth: "Largeur du Rectangle",
        rectHeight: "Hauteur du Rectangle",
        squareSize: "Longueur du côté du Carré",
        solid: "Continu",
        dashed: "Pointillé",
        filled: "Rempli",
        empty: "Vide",
        normal: "Normal",
        reversed: "Inversé",
        circlePoint: "Circulaire",
        xPoint: "X",
        triBase: "Longueur de la base (en cm):",
        triSide2: "Deuxième côté (en cm):",
        triSide3: "Troisième côté (en cm):",
        rhombusOffset: "Distance du centre (en cm):"
      }
    };

    let currentLanguage = 'ar';

    function changeLanguage(lang) {
      currentLanguage = lang;
      document.getElementById("headerTitle").innerText = translations[lang].headerTitle;
      document.getElementById("headerSubtitle").innerText = translations[lang].headerSubtitle;
      document.getElementById("basicToolsCategoryTitle").innerText = translations[lang].basicTools;
      document.getElementById("shapesCategoryTitle").innerText = translations[lang].shapesCategory;
      document.getElementById("additionalToolsTitle").innerText = translations[lang].additionalTools;
      document.querySelectorAll("[data-key]").forEach(el => {
        const key = el.getAttribute("data-key");
        if(translations[lang][key])
          el.innerText = translations[lang][key];
      });
    }
  </script>
</body>
</html>
